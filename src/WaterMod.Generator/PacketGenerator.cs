using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Threading;
using WaterMod.Generator.Models;
using WaterMod.Generator.Utils;
// ReSharper disable VariableHidesOuterVariable

namespace WaterMod.Generator;

[Generator(LanguageNames.CSharp)]
public class PacketGenerator : IIncrementalGenerator
{
    private const string declared_entity_attribute = """
        namespace WaterMod.Generator;

        [global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
        internal class PacketAttribute : global::System.Attribute;
        [global::System.AttributeUsage(global::System.AttributeTargets.Method)]
        internal class PacketHandlerAttribute : global::System.Attribute;
        """;

    private const string packet_attribute_metadata_name = "WaterMod.Generator.PacketAttribute";
    private const string packet_handler_attribute_metadata_name = "WaterMod.Generator.PacketHandlerAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(c => c.AddSource("PacketAttribute.g.cs", declared_entity_attribute));

        IncrementalValuesProvider<PacketModel> models =
            context.SyntaxProvider.ForAttributeWithMetadataName(packet_attribute_metadata_name, (node, _) => node is TypeDeclarationSyntax, CreatePacketModel);

        context.RegisterSourceOutput(models.Select(PacketModelToSource), createSource);

        IncrementalValuesProvider<PacketHandlerModel> handlers =
            context.SyntaxProvider.ForAttributeWithMetadataName(packet_handler_attribute_metadata_name, (node, _) => node is MethodDeclarationSyntax, CreatePacketHandlerModel);

        context.RegisterSourceOutput(handlers.Collect().Combine(models.Collect()).Select(PacketHandlerModelToSource), createSource);

        void createSource(SourceProductionContext ctx, (string Name, string Source) source)
        {
            if (source == default)
                return;
            ctx.AddSource(source.Name, source.Source);
        }
    }

    private static PacketHandlerModel CreatePacketHandlerModel(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        MethodDeclarationSyntax method = (MethodDeclarationSyntax)context.TargetNode;
        if (context.SemanticModel.GetDeclaredSymbol(method) is not IMethodSymbol methodSymbol)
            return default;

        if (methodSymbol.Parameters.Length != 2)
            return default;

        string packetTypeName = methodSymbol.Parameters[0].Type.ToString();

        if (methodSymbol.ReceiverType is null)
            return default;

        return new PacketHandlerModel(methodSymbol.ReceiverType.ToString(), methodSymbol.Name, packetTypeName);
    }

    private static PacketModel CreatePacketModel(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        TypeDeclarationSyntax type = (TypeDeclarationSyntax)context.TargetNode;
        if (context.SemanticModel.GetDeclaredSymbol(type) is not INamedTypeSymbol { TypeKind: TypeKind.Struct } structTypeSymbol)
            return default;
        Stack<TypeDeclarationModel> outerTypes = new();

        INamedTypeSymbol outerType = structTypeSymbol.ContainingType;
        while (outerType is not null)
        {
            outerTypes.Push(new TypeDeclarationModel(
                    outerType.IsRecord,
                    outerType.TypeKind,
                    outerType.Name
                    ));
            outerType = outerType.ContainingType;
        }

        return new PacketModel(
            structTypeSymbol.ContainingNamespace.IsGlobalNamespace ? null : structTypeSymbol.ContainingNamespace.ToString(),
            structTypeSymbol.ToString(),
            new TypeDeclarationModel(structTypeSymbol.IsRecord, TypeKind.Struct, structTypeSymbol.Name),
            new EquatableArray<TypeDeclarationModel>(outerTypes.ToArray()));
    }

    private static (string Name, string Source) PacketHandlerModelToSource((ImmutableArray<PacketHandlerModel>, ImmutableArray<PacketModel>) models, CancellationToken ct)
    {
        var handlerModels = models.Item1;
        var packetModels = models.Item2;

        CodeBuilder cb = new CodeBuilder();

        cb
            .AppendLine("// <auto-generated />")
            .AppendLine()
            .AppendLine("namespace WaterMod.Common.Networking;")
            .AppendLine()
            .AppendLine("partial class NetworkingHandler")
            .Scope()
                .AppendLine("static NetworkingHandler()")
                .Scope()
                    .Foreach(handlerModels.AsSpan(), ct, (in model, cb, _) =>
                    {
                        cb.Append("global::WaterMod.Common.Networking.Packet<global::").Append(model.HandlerFor).Append(">.OnReceive += global::")
                            .Append(model.ReceiverType).Append(".")
                            .Append(model.MethodName)
                            .AppendLine(";");
                    })
                    .AppendLine()
                    .Foreach(packetModels.AsSpan(), ct, (in model, cb, _) =>
                    {
                        cb.Append("RegisterPacketType<global::").Append(model.FullyQualifiedName).AppendLine(">();");
                    })
                .Unscope()
            .Unscope();

        return new("NetworkingHandler.g.cs", cb.ToString());
    }

    private static (string Name, string Source) PacketModelToSource(PacketModel model, CancellationToken ct)
    {
        if (model == default)
            return default;
        CodeBuilder cb = new CodeBuilder();

        string? @namespace = model.Namespace;

        cb
            .AppendLine("// <auto-generated />")
            .AppendLine()
            .If(@namespace is not null, @namespace, (ns, c) => c.Append("namespace ").AppendLine(ns).Scope())

                .Foreach((ReadOnlySpan<TypeDeclarationModel>)model.NestedTypes, ct,
                    (in typeInfo, cb, _) =>
                    cb.Append("partial ").If(typeInfo.IsRecord, c => c.Append("record")).Append(typeInfo.TypeKind switch
                    {
                        TypeKind.Struct => "struct ",
                        TypeKind.Class => "class ",
                        TypeKind.Interface => "interface ",
                        _ => throw new NotImplementedException()
                    }).AppendLine(typeInfo.Name).Scope())

                    .AppendLine("[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]")
                    .Append("partial ").If(model.Type.IsRecord, c => c.Append("record ")).Append("struct ").Append(model.Type.Name).Append(" : global::WaterMod.Common.Networking.IPacket;").AppendLine()

                .Foreach((ReadOnlySpan<TypeDeclarationModel>)model.NestedTypes, ct, (in _, _, _) => cb.Unscope())

            .If(@namespace is not null, c => c.Unscope());

        return new(sanitizeNameForFile(model.Type.Name), cb.ToString());

        static string sanitizeNameForFile(string name)
        {
            const string fileEnd = ".g.cs";
            Span<char> newName = stackalloc char[name.Length + fileEnd.Length];
            for (int i = 0; i < name.Length; i++)
            {
                newName[i] = name[i] switch
                {
                    '<' or '>' => '_',
                    _ => name[i],
                };
            }
            fileEnd.AsSpan().CopyTo(newName.Slice(name.Length));
            string res = newName.ToString();
            return res;
        }
    }

    static bool _launched;

    [Conditional("DEBUG")]
    [DebuggerStepThrough]
    [DebuggerHidden]
    internal static void LaunchDebugger()
    {
        if (!Debugger.IsAttached && !_launched)
            Debugger.Launch();
        _launched = true;
    }
}