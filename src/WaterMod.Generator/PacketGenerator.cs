using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Diagnostics;
using System.Threading;
using WaterMod.Generator.Models;
using WaterMod.Generator.Utils;

namespace WaterMod.Generator;


[Generator(LanguageNames.CSharp)]
public class PacketGenerator : IIncrementalGenerator {
    private const string DeclaredEntityAttribute = """
        using System;

        namespace WaterMod.Generator;

        [AttributeUsage(AttributeTargets.Struct)]
        public class PacketAttribute : Attribute { }
        """;

    private const string PacketAttributeMetadataName = "WaterMod.Generator.PacketAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(c => c.AddSource("PacketAttribute.g.cs", DeclaredEntityAttribute));

        IncrementalValuesProvider<PacketModel> models =
            context.SyntaxProvider.ForAttributeWithMetadataName(PacketAttributeMetadataName, (node, _) => true, CreatePacketModel);

        var sourceFiles = models.Select(ModelToSource);

        context.RegisterSourceOutput(sourceFiles, (ctx, source) =>
        {
            if(source == default)
                return;
            ctx.AddSource(source.Name, source.Source);
        });
    }

    private static PacketModel CreatePacketModel(GeneratorAttributeSyntaxContext context, CancellationToken ct) {
        StructDeclarationSyntax type = (StructDeclarationSyntax)context.TargetNode;
        if(context.SemanticModel.GetDeclaredSymbol(type) is not INamedTypeSymbol { TypeKind: TypeKind.Struct } structTypeSymbol)
            return default;

        Stack<TypeDeclarationModel> outerTypes = new();

        INamedTypeSymbol outerType = structTypeSymbol.ContainingType;
        do {
            outerTypes.Push(new TypeDeclarationModel(
                    outerType.IsRecord,
                    outerType.TypeKind,
                    outerType.Name
                    ));
            outerType = outerType.ContainingType;
        } while(outerType is not null);

        return new PacketModel(
            structTypeSymbol.ContainingNamespace.IsGlobalNamespace ? null : structTypeSymbol.ContainingNamespace.ToString(), 
            new TypeDeclarationModel(structTypeSymbol.IsRecord, TypeKind.Struct, structTypeSymbol.Name), 
            new EquatableArray<TypeDeclarationModel>(outerTypes.ToArray()));
    }

    private static (string Name, string Source) ModelToSource(PacketModel model, CancellationToken ct) {
        if(model == default)
            return default;

        CodeBuilder cb = new CodeBuilder();

        string? @namespace = model.Namespace;

        cb
            .AppendLine("// <auto-generated />")
            .AppendLine()
            .If(@namespace is not null, @namespace, (ns, c) => c.Append("namespace ").AppendLine(ns).Scope())

                .Foreach((ReadOnlySpan<TypeDeclarationModel>)model.NestedTypes, ct,
                    (in TypeDeclarationModel typeInfo, CodeBuilder cb, CancellationToken _) =>
                    cb.Append("partial ").If(typeInfo.IsRecord, c => c.Append("record")).Append(typeInfo.TypeKind switch
                    {
                        TypeKind.Struct => "struct ",
                        TypeKind.Class => "class ",
                        TypeKind.Interface => "interface ",
                        _ => throw new NotImplementedException()
                    }).AppendLine(typeInfo.Name).Scope())
                    
                    .AppendLine("[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]")
                    .Append("partial ").If(model.Type.IsRecord, c => c.Append("record ")).Append("struct ").Append(model.Type.Name).Append(" : global::WaterMod.Networking.IPacket").AppendLine()

                    .Scope()
                    .Unscope()

                .Foreach((ReadOnlySpan<TypeDeclarationModel>)model.NestedTypes, ct, (in TypeDeclarationModel s, CodeBuilder cb, CancellationToken _) => cb.Unscope())

            .If(@namespace is not null, c => c.Unscope());

        return new(SanitizeNameForFile(model.Type.Name), cb.ToString());

        static string SanitizeNameForFile(string name) {
            const string FileEnd = ".g.cs";
            Span<char> newName = stackalloc char[name.Length + FileEnd.Length];
            for(int i = 0; i < name.Length; i++) {
                newName[i] = name[i] switch
                {
                    '<' or '>' => '_',
                    _ => name[i],
                };
            }
            FileEnd.AsSpan().CopyTo(newName.Slice(name.Length));
            string res = newName.ToString();
            return res;
        }
    }

    static bool Launched = false;

    [Conditional("DEBUG")]
    [DebuggerStepThrough]
    [DebuggerHidden]
    internal static void LaunchDebugger() {
        if(!Debugger.IsAttached && !Launched)
            Debugger.Launch();
        Launched = true;
    }
}